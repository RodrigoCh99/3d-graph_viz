import * as THREE from 'three';
import mitt from 'mitt';
import './index.css';
declare type RGB = [number, number, number];
interface GraphData {
    nodes: Array<{
        id: string;
        name?: string;
        scale?: number;
        image?: string;
    }>;
    links: Array<{
        source: string;
        target: string;
        color?: RGB;
    }>;
}
interface GraphBaseConfig {
    width: number;
    height: number;
    nodeSize?: number;
    arrowSize?: number;
    lineWidth?: number;
    showArrow?: boolean;
    backgroundColor?: RGB;
    highLightColor?: RGB;
    showStatTable?: boolean;
    roundedImage?: boolean;
    zoomNear?: number;
    zoomFar?: number;
    debug?: boolean;
}
interface D3ForceData {
    nodes: Array<{
        id: string;
    }>;
    links: Array<D3Link>;
}
interface D3Link {
    source: string;
    target: string;
}
interface ProcessedData extends D3ForceData {
    nodeInfoMap: {
        [key: string]: {
            index: number;
            scale?: number;
            image?: string;
            name?: string;
            imageTexture?: THREE.Texture;
            imagePoint?: ShaderMesh;
        };
    };
    linkInfoMap: {
        [key: string]: {
            color?: RGB;
        };
    };
    linkBuffer: Int32Array;
    statTable: Array<{
        source: string;
        count: number;
    }>;
}
interface Mesh {
    geometry: THREE.BufferGeometry;
    material: THREE.Material;
    mesh: THREE.Mesh | THREE.Points | THREE.LineSegments;
}
interface ShaderMesh extends Mesh {
    material: THREE.ShaderMaterial;
    positions: Float32Array;
    scale?: Float32Array;
    rotates?: Float32Array;
    colors?: Float32Array;
}
interface GraphPerfInfo {
    nodeCounts: number;
    linkCounts: number;
    layoutPastTime: number;
    layoutProgress: string;
    layoutStartTime: number;
    prevTickTime: number;
    targetTick: number;
    intervalTime: number;
    layouting: boolean;
}
interface MouseStatus {
    mouseOnChart: boolean;
    mousePosition: THREE.Vector2;
}
interface ViewportRect {
    left: number;
    right: number;
    top: number;
    bottom: number;
}
interface VisibleNode {
    id: string;
    x: number;
    y: number;
}
export declare class D3ForceGraph {
    $container: HTMLElement;
    containerRect: ClientRect;
    data: GraphData;
    config: GraphBaseConfig;
    perfInfo: GraphPerfInfo;
    processedData: ProcessedData;
    worker: Worker;
    targetPositionStatus: Float32Array;
    currentPositionStatus: Float32Array;
    cachePositionStatus: Float32Array;
    mouseStatus: MouseStatus;
    rafId: number;
    highlighted: string;
    throttleTimer: number;
    events: mitt.Emitter;
    lockHighlightToken: false;
    scene: THREE.Scene;
    renderer: THREE.WebGLRenderer;
    camera: THREE.PerspectiveCamera;
    controls: any;
    nodes: ShaderMesh;
    lines: ShaderMesh;
    arrows: ShaderMesh;
    hlLines: ShaderMesh;
    hlNodes: ShaderMesh;
    hlArrows: ShaderMesh;
    hlText: Mesh;
    constructor(dom: HTMLElement, data: GraphData, graphBaseConfig?: GraphBaseConfig);
    init(): void;
    /**
     * preProcessData
     * preprocess data
     *
     * @returns {ProcessedData}
     * @memberof D3ForceGraph
     */
    preProcessData(): ProcessedData;
    prepareScene(): void;
    prepareBasicMesh(): void;
    initWorker(): void;
    start(): void;
    installControls(): void;
    startRender(): void;
    stopRender(): void;
    render(): void;
    checkFinalStatus(): void;
    renderArrow(): void;
    updatePosition(nodesPosition: Float32Array): void;
    updateHighLight(): void;
    loadImage(): void;
    generateAvaPoint(info: ProcessedData['nodeInfoMap']['key'], id: string, x: number, y: number): void;
    getAllVisibleNodes(): Array<VisibleNode>;
    getViewPortRect(): ViewportRect;
    highlight(id: string): void;
    unhighlight(): void;
    addHighLight(sourceId: string): void;
    mouseMoveHandler(event: MouseEvent): void;
    mouseOutHandler(): void;
    mouseMoveHandlerBinded: any;
    mouseOutHandlerBinded: any;
    chartMouseEnterHandler(): void;
    chartMouseLeaveHandler(): void;
    chartMouseEnterHandlerBinded: any;
    chartMouseLeaveHandlerBinded: any;
    bindEvent(): void;
    unbindEvent(): void;
    destroy(): void;
    resize(width: number, height: number): void;
    getPositionZ(nodesCount: number): number;
    getDistance(nodesCount: number): number;
    getStrength(nodesCount: number): number;
    getCol(nodesCount: number): number;
}
export {};
